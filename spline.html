<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
	</head>
	<body>
		<script>
		 function makeDoubleDelegate(f1,f2) {
			 "use strict";
			 return function() {
				 if (f1) f1();
				 if (f2) f2();
			 }
		 }
		</script>

        <script>
         function makeSplineCardinal(controlPoints, tau) {
             "use strict";
             var iSeg,iSamp;
             var segs = [];
             for(iSeg=0; iSeg<controlPoints.length-3; iSeg+=1) {
                 var p0 = controlPoints[iSeg+0];
                 var p1 = controlPoints[iSeg+1];
                 var p2 = controlPoints[iSeg+2];
                 var p3 = controlPoints[iSeg+3];
                 var m = {
                     m00: p1.x,
                     m01: p1.y,
                     m02: 0,
                     m03: 0,
                     m10: (-tau)*p0.x + (tau)*p2.x,
                     m11: (-tau)*p0.y + (tau)*p2.y,
                     m12: 0,
                     m13: 0,
                     m20: (2*tau)*p0.x + (tau-3)*p1.x + (3-2*tau)*p2.x + (-tau)*p3.x,
                     m21: (2*tau)*p0.y + (tau-3)*p1.y + (3-2*tau)*p2.y + (-tau)*p3.y,
                     m22: 0,
                     m23: 0,
                     m30: (-tau)*p0.x + (2-tau)*p1.x + (tau-2)*p2.x + (tau)*p3.x,
                     m31: (-tau)*p0.y + (2-tau)*p1.y + (tau-2)*p2.y + (tau)*p3.y,
                     m32: 0,
                     m33: 0
                 }
                 segs.push({
                     geomMatrix: m,
                 });
             }

             function eval1(u) {
                 var uInt = u | 0, uFrac = u - uInt;
                 if (uInt < 0 || uInt >= segs.length) {
                     return null;
                 }
                 var m = segs[uInt].geomMatrix;
                 return {
                     x: ((m.m30*uFrac + m.m20)*uFrac + m.m10)*uFrac + m.m00,
                     y: ((m.m31*uFrac + m.m21)*uFrac + m.m11)*uFrac + m.m01
                 };
             }
             
             return {
                 points: controlPoints,
                 segments: segs,
                 tau: tau,
                 eval1: eval1
             };
         }

         function makeSplineHermite(controlPointsAndTangents) {
             "use strict";
             var iSeg,iSamp;
             var segs = [];
             for(iSeg=0; iSeg<controlPointsAndTangents.length-1; iSeg+=1) {
                 var p0 = controlPointsAndTangents[iSeg+0];
                 var p1 = controlPointsAndTangents[iSeg+1];
                 var m = {
                     m00: p0.x,
                     m01: p0.y,
                     m02: 0,
                     m03: 0,
                     m10: p0.tx,
                     m11: p0.ty,
                     m12: 0,
                     m13: 0,
                     m20: (-3)*p0.x + (3)*p1.x + (-2)*p0.tx + (-1)*p1.tx,
                     m21: (-3)*p0.y + (3)*p1.y + (-2)*p0.ty + (-1)*p1.ty,
                     m22: 0,
                     m23: 0,
                     m30: (2)*p0.x + (-2)*p1.x + p0.tx + p1.tx,
                     m31: (2)*p0.y + (-2)*p1.y + p0.ty + p1.ty,
                     m32: 0,
                     m33: 0
                 }
                 segs.push({
                     geomMatrix: m,
                 });
             }
             
             function eval1(u) {
                 var uInt = u | 0, uFrac = u - uInt;
                 if (uInt < 0 || uInt >= segs.length) {
                     return null;
                 }
                 var m = segs[uInt].geomMatrix;
                 return {
                     x: ((m.m30*uFrac + m.m20)*uFrac + m.m10)*uFrac + m.m00,
                     y: ((m.m31*uFrac + m.m21)*uFrac + m.m11)*uFrac + m.m01
                 };
             }

             return {
                 points: controlPointsAndTangents,
                 segments: segs,
                 eval1: eval1
             };
         }

         function makeSplineBezier(controlPointsAndTangents) {
             "use strict";
             var iSeg,iSamp;
             var segs = [];
             for(iSeg=0; iSeg<controlPointsAndTangents.length-1; iSeg+=1) {
                 var p0 = controlPointsAndTangents[iSeg+0];
                 var p1 = {
                     x:controlPointsAndTangents[iSeg+0].x + controlPointsAndTangents[iSeg+0].tx,
                     y:controlPointsAndTangents[iSeg+0].y + controlPointsAndTangents[iSeg+0].ty,
                 };
                 var p2 = {
                     x:controlPointsAndTangents[iSeg+1].x - controlPointsAndTangents[iSeg+1].tx,
                     y:controlPointsAndTangents[iSeg+1].y - controlPointsAndTangents[iSeg+1].ty,
                 };
                 var p3 = controlPointsAndTangents[iSeg+1];
                 var m = {
                     m00: p0.x,
                     m01: p0.y,
                     m02: 0,
                     m03: 0,
                     m10: (-3)*p0.x + (3*p1.x),
                     m11: (-3)*p0.y + (3*p1.y),
                     m12: 0,
                     m13: 0,
                     m20: (3)*p0.x + (-6)*p1.x + (3)*p2.x,
                     m21: (3)*p0.y + (-6)*p1.y + (3)*p2.y,
                     m22: 0,
                     m23: 0,
                     m30: (-1)*p0.x + (3)*p1.x + (-3)*p2.x + p3.x,
                     m31: (-1)*p0.y + (3)*p1.y + (-3)*p2.y + p3.y,
                     m32: 0,
                     m33: 0
                 }
                 segs.push({
                     geomMatrix: m,
                 });
             }
             
             function eval1(u) {
                 var uInt = u | 0, uFrac = u - uInt;
                 if (uInt < 0 || uInt >= segs.length) {
                     return null;
                 }
                 var m = segs[uInt].geomMatrix;
                 return {
                     x: ((m.m30*uFrac + m.m20)*uFrac + m.m10)*uFrac + m.m00,
                     y: ((m.m31*uFrac + m.m21)*uFrac + m.m11)*uFrac + m.m01
                 };
             }

             return {
                 points: controlPointsAndTangents,
                 segments: segs,
                 eval1: eval1
             };
         }

         function makeSplineCatmullRomCentripetal(controlPoints, alpha) {
             "use strict";
             var iSeg,iSamp;
             var segs = [];
             for(iSeg=0; iSeg<controlPoints.length-3; iSeg+=1) {
                 var p0 = controlPoints[iSeg+0];
                 var p1 = controlPoints[iSeg+1];
                 var p2 = controlPoints[iSeg+2];
                 var p3 = controlPoints[iSeg+3];
                 var t0 = 0;
                 var t1 = t0 + Math.pow( (p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y), alpha*0.5 );
                 var t2 = t1 + Math.pow( (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y), alpha*0.5 );
                 var t3 = t2 + Math.pow( (p3.x-p2.x)*(p3.x-p2.x) + (p3.y-p2.y)*(p3.y-p2.y), alpha*0.5 );
                 segs.push({
                     t0: t0,
                     t1: t1,
                     t2: t2,
                     t3: t3
                 });
             }
             
             function eval1(u) {
                 var uInt = u | 0, uFrac = u - uInt;
                 if (uInt < 0 || uInt >= segs.length) {
                     return null;
                 }
                 var p0 = controlPoints[uInt+0];
                 var p1 = controlPoints[uInt+1];
                 var p2 = controlPoints[uInt+2];
                 var p3 = controlPoints[uInt+3];
                 var t0     = segs[uInt].t0;
                 var t1     = segs[uInt].t1;
                 var t2     = segs[uInt].t2;
                 var t3     = segs[uInt].t3;
                 
                 var t2_t1  =  t2-t1;
                 var t3_t2i = 1.0 / (t3-t2);
                 var t3_t1i = 1.0 / (t3-t1);
                 var t2_t1i = 1.0 / (t2-t1);
                 var t2_t0i = 1.0 / (t2-t0);
                 var t1_t0i = 1.0 / (t1-t0);
                 
                 var tu = t1 + uFrac*t2_t1;
                 var t0_tu = t0-tu;
                 var t1_tu = t1-tu;
                 var t2_tu = t2-tu;
                 var t3_tu = t3-tu;
                 
                 var a1 = {
                     x: (t1_tu*p0.x - t0_tu*p1.x)*t1_t0i,
                     y: (t1_tu*p0.y - t0_tu*p1.y)*t1_t0i
                 };
                 var a2 = {
                     x: (t2_tu*p1.x - t1_tu*p2.x)*t2_t1i,
                     y: (t2_tu*p1.y - t1_tu*p2.y)*t2_t1i
                 };
                 var a3 = {
                     x: (t3_tu*p2.x - t2_tu*p3.x)*t3_t2i,
                     y: (t3_tu*p2.y - t2_tu*p3.y)*t3_t2i
                 };
                 var b1 = {
                     x: (t2_tu*a1.x - t0_tu*a2.x)*t2_t0i,
                     y: (t2_tu*a1.y - t0_tu*a2.y)*t2_t0i
                 };
                 var b2 = {
                     x: (t3_tu*a2.x - t1_tu*a3.x)*t3_t1i,
                     y: (t3_tu*a2.y - t1_tu*a3.y)*t3_t1i
                 };
                 var c = {
                     x: (t2_tu*b1.x - t1_tu*b2.x)*t2_t1i,
                     y: (t2_tu*b1.y - t1_tu*b2.y)*t2_t1i
                 };
                 return c;
             }

             return {
                 points: controlPoints,
                 segments: segs,
                 alpha: alpha,
                 eval1: eval1
             };
         }
        </script>
        
		<canvas id="splineCanvas" width="600" height="600"
			    style="border:1px solid black;">
			Canvas is not supported by your browser. WTF dude.
		</canvas><br>
        <label for="tauInput">Tau (tension):</label><input type="number" id="tauInput" name="tauInput" value="0.5" step="0.1"/><br>
        <label for="alphaInput">Alpha:</label><input type="number" id="alphaInput" name="alphaInput" value="0.5" step="0.1"/><br>
        <label for="samplesInput">Detail:</label><input type="range" id="samplesInput" name="samplesInput" min="1" max="32" value="16" step="1"/><br>
		<script>
		 var spinAngle = 0;
		 var timeStampPrevious;
		 function drawCanvasAnim(timeStamp) {
			 "use strict";
			 if (typeof timeStampPrevious === 'undefined')
			     timeStampPrevious = timeStamp;
			 var dtSec = (timeStamp - timeStampPrevious) * 0.001;
			 timeStampPrevious = timeStamp;
			 
             var controlPoints = [
                 {x:-1.0, y: 0.0},
                 {x:-1.01,y: 0.0},
                 {x: 0.99,y: 1.0},
                 {x: 1.0, y: 0.99},
                 {x: 0.0, y:-1.01},
                 {x: 0.0, y:-1.0}
             ];
             var controlPointsAndTangents = [
                 {x:-1.0,y: 0.0,tx: 0.0,ty: 1.0},
                 {x: 0.0,y: 1.0,tx: 0.0,ty: 1.0},
                 {x: 1.0,y: 0.0,tx: 0.0,ty:-1.0},
             ];

             var splineC = makeSplineCardinal(controlPoints, document.querySelector("#tauInput").value);
             var splineCRC = makeSplineCatmullRomCentripetal(controlPoints, document.querySelector("#alphaInput").value);
             var splineH = makeSplineHermite(controlPointsAndTangents);
             var splineB = makeSplineBezier(controlPointsAndTangents);
             
             function renderPoints(ctx, points) {
                 var iPt;
                 for(iPt=0; iPt<points.length; iPt+=1) {
                     ctx.fillRect(points[iPt].x-.02, points[iPt].y-.02, .04, .04);
                 }
             }
             function renderCurve(ctx, spline, samplesPerSegment) {
                 var u, du = 1 / samplesPerSegment;
                 ctx.beginPath();
                 for(u=0; u<spline.segments.length; u+=du) {
                     var pt = spline.eval1(u);
                     ctx.lineTo(pt.x,pt.y);
                 }
                 ctx.lineTo(spline.points[spline.points.length-1].x, spline.points[spline.points.length-1].y);
                 ctx.stroke();
             }
             
			 var canvas = document.querySelector("#splineCanvas");
			 var ctx = canvas.getContext("2d");
             var samplesPerSegment = document.querySelector("#samplesInput").value;
			 ctx.save();
			 ctx.clearRect(0,0, canvas.width, canvas.height);
             ctx.translate(canvas.width/2, canvas.height/2);
             ctx.scale( canvas.width/4, canvas.height/4);
             ctx.lineWidth = 0.01;
             // Cardinal
             ctx.fillStyle = "red";
             renderPoints(ctx, controlPoints);
             ctx.strokeStyle = "red";
             renderCurve(ctx, splineC, samplesPerSegment);
             // Centripetal Catmull-Rom
             ctx.strokeStyle = "blue";
             renderCurve(ctx, splineCRC, samplesPerSegment);
             // Hermite
             ctx.fillStyle = "green";
             renderPoints(ctx, controlPointsAndTangents);
             ctx.strokeStyle = "green";
             renderCurve(ctx, splineH, samplesPerSegment);
             // Bezier
             ctx.strokeStyle = "purple";
             renderCurve(ctx, splineB, samplesPerSegment);

			 ctx.restore();
			 var requestId = requestAnimationFrame(drawCanvasAnim);
		 }
		 window.onload= makeDoubleDelegate(window.onload, function() {
			 "use strict";
			 var requestId = requestAnimationFrame(drawCanvasAnim);
		 });
		</script>
	</body>
</html>
